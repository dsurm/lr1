# Описание 
## Архитектура
Проект состоит из четырёх Docker контейнеров:
1.	pg_arbitrator – арбитр;
2.	pg_master – мастер;
3.	pg_slave - слейв;
4.  pg_test - тестировщик pg_master;

В качестве базового образа для контейнеров pg_master, pg_slave, pg_test используется bitnami/postgresql:16.3.0 (https://github.com/bitnami/containers/blob/main/bitnami/postgresql/README.md).

Во всех контейнерах перечисленных выше контейнерах, кроме pg_test, крутиться программа-агент. Образы pg_master и pg_slave идентичны между собой, за исключением различных вариантов программ-агентов.

## Логика работы агента
Сценарий работы при потере сетевой связности:
- Программа-агент запущенная на pg_arbitrator, поднимает http лисинер на порту 8080. При потере связи с pg_master, начинает возвращать статус-код не 200, а 500.
- Программа-агент запущенная на pg_master, при обнаружении потери связи с pg_arbitrator и pg_slave - тушит СУБД на pg_master.
- Программа-агент запущенная на pg_slave, при потере связи с pg_master делает http запрос к лисенеру на pg_arbitrator и при получении 500 кода ответа выполняет promote до master-a.

# Эксплуатация
## Настройка
По сути настройка не требуется. 

DISCLAIMER

При использовании данного решения в бою - требуется сменить креды, хранящиеся в файлах переменных окружения:
```
./config/pg_arbitrator/example.env
./config/pg_master/example.env
./config/pg_slave/example.env
./config/pg_test/example.env
```

## Запуск
В папке проекта выполнить команду:
```
docker compose up -d pg_arbitrator pg_master pg_slave
# pg_test не имеет смысла запускать, так как он начнёт нагружать мастер до того как он прогрузится и будет сыпать ошибками
```

## Тестирование
1. Запустить контейнеры командой выше;
2. Проверить состояние арбитра выполнив команду из хостовой ОС (код ответа должен быть 200):
```
curl http://127.0.0.1:8080
```
3. Запустить нагрузочное тестирование мастера:
```
docker compose start pg_test
```
4. Потушить мастер командой:
```
docker compose stop pg_master
```
5. Подождать 10-15 секунд, проверить состояние арбитра (код ответа должен быть 500):
```
curl http://127.0.0.1:8080
```
6. Подключиться из хостовой ОС к pg_slave (креды от него лежат в файле ./config/pg_slave/example.env). В базе бывшего слейва должны появится таблицы, созданные программой pg_bench в мастере на этапе 3. Далее можно попробовать создать таблицу, например, с помощью SQL команды: `CREATE TABLE x(i INT);`, если это удалось, то slave успешно переведён в master.


P.S.
Логи healthcheck-а не пишутся в stdout по умолчанию, отдельно их можно посмотреть с помощью команды:
```
docker inspect --format "{{json .State.Health }}" <container_name>
```